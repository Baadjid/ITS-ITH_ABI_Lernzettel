<!DOCTYPE html>
<html lang="de">
<head>
     <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithmen & Datenstrukturen - Erweitert - Abitur TG 2026</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #2563eb;
            --secondary-color: #1e40af;
            --accent-color: #3b82f6;
            --text-dark: #1e293b;
            --text-light: #64748b;
            --bg-light: #f8fafc;
            --bg-white: #ffffff;
            --border-color: #e2e8f0;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --danger-color: #ef4444;
            --code-bg: #1e293b;
            --code-text: #e2e8f0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-dark);
            background: linear-gradient(135deg, var(--bg-light) 0%, #e0e7ff 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: var(--bg-white);
            padding: 2rem;
            border-radius: 16px;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--border-color);
            text-align: center;
        }

        .header h1 {
            color: var(--primary-color);
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }

        .breadcrumb {
            background: var(--bg-white);
            padding: 1rem 2rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            border: 1px solid var(--border-color);
        }

        .breadcrumb a {
            color: var(--primary-color);
            text-decoration: none;
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        .section {
            background: var(--bg-white);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--border-color);
        }

        .section h2 {
            color: var(--primary-color);
            font-size: 1.8rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .section h3 {
            color: var(--secondary-color);
            font-size: 1.4rem;
            margin: 2rem 0 1rem 0;
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 0.5rem;
        }

        .section h4 {
            color: var(--text-dark);
            font-size: 1.2rem;
            margin: 1.5rem 0 0.5rem 0;
        }

        .intro-box {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 1.5rem;
            border-radius: 12px;
            margin-bottom: 2rem;
        }

        .intro-box h3 {
            margin: 0 0 1rem 0;
            border: none;
            padding: 0;
            color: white;
        }

        .definition-box {
            background: #f0f9ff;
            border-left: 4px solid var(--primary-color);
            padding: 1.5rem;
            margin: 1rem 0;
            border-radius: 0 8px 8px 0;
        }

        .definition-box strong {
            color: var(--primary-color);
        }

        .example-box {
            background: #f0fdf4;
            border-left: 4px solid var(--success-color);
            padding: 1.5rem;
            margin: 1rem 0;
            border-radius: 0 8px 8px 0;
        }

        .warning-box {
            background: #fffbeb;
            border-left: 4px solid var(--warning-color);
            padding: 1.5rem;
            margin: 1rem 0;
            border-radius: 0 8px 8px 0;
        }

        .code-block {
            background: var(--code-bg);
            color: var(--code-text);
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
            overflow-x: auto;
            font-family: 'Fira Code', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            position: relative;
        }

        .code-block::before {
            content: 'Java';
            position: absolute;
            top: 0.5rem;
            right: 1rem;
            background: var(--primary-color);
            color: white;
            padding: 0.2rem 0.6rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .code-block .comment {
            color: #94a3b8;
            font-style: italic;
        }

        .code-block .keyword {
            color: #60a5fa;
            font-weight: bold;
        }

        .code-block .string {
            color: #34d399;
        }

        .code-block .number {
            color: #fbbf24;
        }

        .code-block .operator {
            color: #f87171;
        }

        /* Code-Bl√∂cke mit pre/code */
pre {
    background: var(--code-bg);
    color: var(--code-text);
    padding: 1.5rem;
    border-radius: 8px;
    margin: 1rem 0;
    overflow-x: auto;
    font-family: 'Fira Code', 'Consolas', 'Monaco', 'Courier New', monospace;
    font-size: 0.85rem;
    line-height: 1.6;
    position: relative;
    white-space: pre;
    tab-size: 4;
    max-height: 600px;
    overflow-y: auto;
}

pre code {
    background: none;
    padding: 0;
    font-size: inherit;
    color: inherit;
    font-family: inherit;
}

/* Scrollbar f√ºr Code-Bl√∂cke */
pre::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

pre::-webkit-scrollbar-track {
    background: #0f172a;
    border-radius: 4px;
}

pre::-webkit-scrollbar-thumb {
    background: #475569;
    border-radius: 4px;
}

pre::-webkit-scrollbar-thumb:hover {
    background: #64748b;
}

/* Language Label (optional) */
pre::before {
    content: 'Java';
    position: absolute;
    top: 0.5rem;
    right: 1rem;
    background: var(--primary-color);
    color: white;
    padding: 0.2rem 0.6rem;
    border-radius: 4px;
    font-size: 0.7rem;
    font-weight: bold;
    font-family: 'Segoe UI', sans-serif;
}

        .visual-demo {
            background: var(--bg-light);
            padding: 2rem;
            border-radius: 12px;
            margin: 1.5rem 0;
            text-align: center;
            border: 2px dashed var(--border-color);
        }

        .linked-list-visual {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin: 2rem 0;
            flex-wrap: wrap;
        }

        .node-box {
            background: white;
            border: 3px solid var(--primary-color);
            border-radius: 8px;
            padding: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .node-data {
            background: var(--accent-color);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-weight: bold;
            min-width: 50px;
            text-align: center;
        }

        .node-arrow {
            font-size: 1.5rem;
            color: var(--primary-color);
        }

        .null-box {
            background: #fee2e2;
            color: #991b1b;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-weight: bold;
            border: 2px solid #ef4444;
        }

        .array-visualization {
            display: flex;
            gap: 4px;
            justify-content: center;
            margin: 1rem 0;
            flex-wrap: wrap;
        }

        .array-cell {
            width: 50px;
            height: 50px;
            border: 2px solid var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-white);
            font-weight: bold;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .array-cell:hover {
            transform: scale(1.1);
            background: var(--accent-color);
            color: white;
        }

        .array-index {
            font-size: 0.8rem;
            color: var(--text-light);
            margin-top: 0.5rem;
        }

        .stack-demo, .queue-demo {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .stack-item, .queue-item {
            width: 100px;
            height: 40px;
            background: var(--accent-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-weight: bold;
            transition: transform 0.3s ease;
        }

        .stack-item:hover, .queue-item:hover {
            transform: scale(1.05);
        }

        .queue-demo {
            flex-direction: row;
        }

        .algorithm-comparison {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1rem;
            margin: 2rem 0;
        }

        .algorithm-card {
            background: var(--bg-white);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .algorithm-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1);
        }

        .algorithm-card h4 {
            color: var(--primary-color);
            margin: 0 0 1rem 0;
        }

        .complexity-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .complexity-table th,
        .complexity-table td {
            border: 1px solid var(--border-color);
            padding: 0.75rem;
            text-align: left;
        }

        .complexity-table th {
            background: var(--bg-light);
            color: var(--text-dark);
            font-weight: bold;
        }

        .complexity-good {
            background: #dcfce7;
            color: #166534;
        }

        .complexity-medium {
            background: #fef3c7;
            color: #92400e;
        }

        .complexity-bad {
            background: #fee2e2;
            color: #991b1b;
        }

        .step-by-step {
            background: var(--bg-light);
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .step {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .step:last-child {
            margin-bottom: 0;
        }

        .step-number {
            background: var(--primary-color);
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            flex-shrink: 0;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 3rem;
            padding: 1.5rem;
            background: var(--bg-white);
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .nav-button {
            display: inline-block;
            padding: 0.75rem 1.5rem;
            background: var(--primary-color);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            transition: background-color 0.3s ease;
        }

        .nav-button:hover {
            background: var(--secondary-color);
        }

        .tree-visualization {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            margin: 2rem 0;
        }

        .tree-level {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .tree-node {
            width: 40px;
            height: 40px;
            border: 2px solid var(--primary-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-white);
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .tree-node:hover {
            background: var(--primary-color);
            color: white;
            transform: scale(1.1);
        }

        .interactive-demo {
            background: var(--bg-white);
            border: 2px solid var(--primary-color);
            border-radius: 12px;
            padding: 2rem;
            margin: 2rem 0;
        }

        .demo-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .demo-button {
            padding: 0.5rem 1rem;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .demo-button:hover {
            background: var(--primary-color);
            transform: translateY(-1px);
        }

        .demo-button:active {
            transform: translateY(0);
        }

        input[type="number"], input[type="text"] {
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 1rem;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 2rem 0;
        }

        .comparison-card {
            background: var(--bg-light);
            padding: 1.5rem;
            border-radius: 8px;
            border: 2px solid var(--border-color);
        }

        .comparison-card h4 {
            color: var(--primary-color);
            margin-bottom: 1rem;
        }

        .pros-cons {
            margin-top: 1rem;
        }

        .pros-cons h5 {
            margin-bottom: 0.5rem;
        }

        .pros {
            color: var(--success-color);
        }

        .cons {
            color: var(--danger-color);
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .array-visualization {
                justify-content: flex-start;
            }

            .array-cell {
                width: 40px;
                height: 40px;
            }

            .algorithm-comparison {
                grid-template-columns: 1fr;
            }

            .comparison-grid {
                grid-template-columns: 1fr;
            }

            .navigation {
                flex-direction: column;
                gap: 1rem;
            }

            .linked-list-visual {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="breadcrumb">
            <a href="index.html">üè† Startseite</a> > 
            <a href="index.html">üíª Grundlagen der Programmentwicklung</a> > 
            <strong>üìä Algorithmen & Datenstrukturen (Erweitert)</strong>
        </div>

        <header class="header">
            <h1>üìä Algorithmen & Datenstrukturen</h1>
            <p>Vollst√§ndiger Guide mit Generics, verketteten Listen und inneren Klassen</p>
        </header>

        <div class="intro-box">
            <h3>üéØ Was du in diesem erweiterten Kapitel lernst</h3>
            <p>Dieses Kapitel deckt ALLE wichtigen Konzepte f√ºr dein Abitur ab: von den Grundlagen √ºber Generics, verkettete Listen mit vollst√§ndiger Implementierung, innere Klassen (static vs. non-static), Java Collections Framework bis hin zu fortgeschrittenen Algorithmen. Nach diesem Kapitel bist du bestens vorbereitet!</p>
        </div>

        <!-- INHALTSVERZEICHNIS -->
        <section class="section">
            <h2>üìë Inhaltsverzeichnis</h2>
            <div class="algorithm-comparison">
                <div class="algorithm-card">
                    <h4>Grundlagen</h4>
                    <ul>
                        <li>1. Algorithmen Grundlagen</li>
                        <li>2. Datenstrukturen Grundlagen</li>
                        <li>3. Arrays (1D & 2D)</li>
                    </ul>
                </div>
                <div class="algorithm-card">
                    <h4>Generics & OOP</h4>
                    <ul>
                        <li>4. Generics verstehen</li>
                        <li>5. Innere Klassen (static vs. non-static)</li>
                        <li>6. Verkettete Listen mit Generics</li>
                    </ul>
                </div>
                <div class="algorithm-card">
                    <h4>Dynamische Strukturen</h4>
                    <ul>
                        <li>7. Stack & Queue</li>
                        <li>8. Java Collections Framework</li>
                        <li>9. Bin√§rb√§ume</li>
                    </ul>
                </div>
                <div class="algorithm-card">
                    <h4>Algorithmen</h4>
                    <ul>
                        <li>10. Sortieralgorithmen</li>
                        <li>11. Suchalgorithmen</li>
                        <li>12. Rekursion vs. Iteration</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- 1. Algorithmen Grundlagen (kurz) -->
        <section class="section">
            <h2>üßÆ 1. Was sind Algorithmen?</h2>
            
            <div class="definition-box">
                <strong>Definition:</strong> Ein Algorithmus ist eine Verarbeitungsvorschrift aus endlich vielen eindeutigen Anweisungen zur L√∂sung einer Aufgabe.
            </div>

            <h3>üìã Eigenschaften</h3>
            <ul>
                <li><strong>Eindeutigkeit:</strong> Jeder Schritt ist klar definiert</li>
                <li><strong>Endlichkeit:</strong> Algorithmus terminiert nach endlich vielen Schritten</li>
                <li><strong>Ausf√ºhrbarkeit:</strong> Jede Anweisung ist ausf√ºhrbar</li>
                <li><strong>Determinismus:</strong> Gleiche Eingaben ‚Üí Gleiche Ergebnisse</li>
            </ul>

            <h3>üèóÔ∏è Grundbausteine</h3>
            <div class="algorithm-comparison">
                <div class="algorithm-card">
                    <h4>Sequenz</h4>
                    <p>Anweisungen nacheinander</p>
                    <div class="code-block">
int a = 5;
int b = 10;
int summe = a + b;
                    </div>
                </div>
                <div class="algorithm-card">
                    <h4>Verzweigung</h4>
                    <p>Bedingte Ausf√ºhrung</p>
                    <div class="code-block">
if (alter >= 18) {
    System.out.println("Vollj√§hrig");
} else {
    System.out.println("Minderj√§hrig");
}
                    </div>
                </div>
                <div class="algorithm-card">
                    <h4>Schleife</h4>
                    <p>Wiederholte Ausf√ºhrung</p>
                    <div class="code-block">
for (int i = 0; i < 5; i++) {
    System.out.println(i);
}
                    </div>
                </div>
            </div>
        </section>

        <!-- 2. Datenstrukturen Grundlagen -->
        <section class="section">
            <h2>üì¶ 2. Datenstrukturen Grundlagen</h2>
            
            <div class="definition-box">
                <strong>Datenstruktur:</strong> Ein Konzept zur Speicherung und Organisation von Daten f√ºr effizienten Zugriff und Verarbeitung.
            </div>

            <div class="comparison-grid">
                <div class="comparison-card">
                    <h4>üìè Statische Datenstrukturen</h4>
                    <ul>
                        <li>Feste Gr√∂√üe bei Erstellung</li>
                        <li>Schneller Zugriff</li>
                        <li>Weniger flexibel</li>
                    </ul>
                    <strong>Beispiel:</strong> Arrays
                </div>
                <div class="comparison-card">
                    <h4>üìà Dynamische Datenstrukturen</h4>
                    <ul>
                        <li>Gr√∂√üe √§ndert sich zur Laufzeit</li>
                        <li>Flexibler</li>
                        <li>Etwas langsamer</li>
                    </ul>
                    <strong>Beispiele:</strong> Listen, Stacks, Queues
                </div>
            </div>
        </section>

        <!-- 3. Arrays -->
        <section class="section">
            <h2>üìã 3. Arrays - Die Grundlage</h2>
            
            <div class="definition-box">
                <strong>Array:</strong> Eine statische Datenstruktur mit fester Gr√∂√üe, die mehrere Elemente gleichen Datentyps speichert. Zugriff √ºber Index (beginnt bei 0).
            </div>

            <h3>üî¢ Eindimensionale Arrays</h3>
            
            <div class="visual-demo">
                <h4>Visualisierung: int[] zahlen = {42, 17, 8, -5, 23}</h4>
                <div class="array-visualization">
                    <div>
                        <div class="array-cell">42</div>
                        <div class="array-index">Index 0</div>
                    </div>
                    <div>
                        <div class="array-cell">17</div>
                        <div class="array-index">Index 1</div>
                    </div>
                    <div>
                        <div class="array-cell">8</div>
                        <div class="array-index">Index 2</div>
                    </div>
                    <div>
                        <div class="array-cell">-5</div>
                        <div class="array-index">Index 3</div>
                    </div>
                    <div>
                        <div class="array-cell">23</div>
                        <div class="array-index">Index 4</div>
                    </div>
                </div>
            </div>

            <div class="code-block">
// Array erstellen
int[] zahlen = new int[5];  // 5 Pl√§tze

// Werte zuweisen
zahlen[0] = 42;
zahlen[1] = 17;

// Direkte Initialisierung
int[] fertig = {42, 17, 8, -5, 23};

// Durchlaufen
for (int i = 0; i < zahlen.length; i++) {
    System.out.println(zahlen[i]);
}

// Enhanced for-loop
for (int zahl : zahlen) {
    System.out.println(zahl);
}
            </div>

            <div class="warning-box">
                <strong>‚ö†Ô∏è Wichtig:</strong> Array-Indizes beginnen bei 0! Ein Array mit 5 Elementen hat Indizes 0-4.
            </div>
        </section>

        <!-- 4. GENERICS - NEU UND AUSF√úHRLICH -->
        <section class="section">
            <h2>üéÅ 4. Generics - Flexibler Code f√ºr jeden Datentyp</h2>
            
            <div class="definition-box">
                <strong>Generics:</strong> Erm√∂glichen es, Klassen und Methoden zu schreiben, die mit verschiedenen Datentypen arbeiten k√∂nnen, ohne den Code zu duplizieren. Der Typ wird als Parameter √ºbergeben.
            </div>

            <h3>ü§î Warum Generics?</h3>
            
            <div class="comparison-grid">
                <div class="comparison-card">
                    <h4>‚ùå Ohne Generics</h4>
                    <div class="code-block">
// Separate Klassen f√ºr jeden Typ
class StringListe {
    String[] daten;
    // ...
}

class IntegerListe {
    Integer[] daten;
    // ...
}

class AutoListe {
    Auto[] daten;
    // ...
}

// Code-Duplikation!
                    </div>
                </div>
                <div class="comparison-card">
                    <h4>‚úÖ Mit Generics</h4>
                    <div class="code-block">
// EINE Klasse f√ºr ALLE Typen!
class Liste<T> {
    T[] daten;
    // ...
}

// Verwendung
Liste<String> strings = new Liste<>();
Liste<Integer> zahlen = new Liste<>();
Liste<Auto> autos = new Liste<>();

// Kein Code dupliziert!
                    </div>
                </div>
            </div>

            <h3>üìù Generics Syntax</h3>
            
            <div class="code-block">
// T = Type Parameter (Platzhalter f√ºr jeden Typ)
public class Box<T> {
    private T inhalt;
    
    public void setInhalt(T inhalt) {
        this.inhalt = inhalt;
    }
    
    public T getInhalt() {
        return inhalt;
    }
}

// Verwendung
Box<String> stringBox = new Box<>();
stringBox.setInhalt("Hallo");
String s = stringBox.getInhalt();  // Kein Cast n√∂tig!

Box<Integer> intBox = new Box<>();
intBox.setInhalt(42);
Integer i = intBox.getInhalt();
            </div>

            <h3>üéØ Type Parameter Konventionen</h3>
            
            <table class="complexity-table">
                <tr>
                    <th>Buchstabe</th>
                    <th>Bedeutung</th>
                    <th>Beispiel</th>
                </tr>
                <tr>
                    <td><strong>T</strong></td>
                    <td>Type (allgemeiner Typ)</td>
                    <td>class Box&lt;T&gt;</td>
                </tr>
                <tr>
                    <td><strong>E</strong></td>
                    <td>Element</td>
                    <td>ArrayList&lt;E&gt;</td>
                </tr>
                <tr>
                    <td><strong>K</strong></td>
                    <td>Key (Schl√ºssel)</td>
                    <td>HashMap&lt;K, V&gt;</td>
                </tr>
                <tr>
                    <td><strong>V</strong></td>
                    <td>Value (Wert)</td>
                    <td>HashMap&lt;K, V&gt;</td>
                </tr>
            </table>

            <h3>‚ú® Vorteile von Generics</h3>
            
            <div class="example-box">
                <h4>1. Typ-Sicherheit zur Compile-Zeit</h4>
                <div class="code-block">
ArrayList<String> liste = new ArrayList<>();
liste.add("Text");     // ‚úÖ OK
liste.add(123);        // ‚ùå FEHLER! Compiler f√§ngt es ab
                </div>
            </div>

            <div class="example-box">
                <h4>2. Kein Casting n√∂tig</h4>
                <div class="code-block">
// Ohne Generics
ArrayList liste = new ArrayList();
liste.add("Text");
String s = (String) liste.get(0);  // Cast n√∂tig

// Mit Generics
ArrayList<String> liste = new ArrayList<>();
liste.add("Text");
String s = liste.get(0);  // Kein Cast n√∂tig!
                </div>
            </div>

            <div class="example-box">
                <h4>3. Code-Wiederverwendung</h4>
                <p>Eine generische Klasse funktioniert mit allen Typen!</p>
            </div>

            <h3>üîß Generische Methoden</h3>
            
            <div class="code-block">
public class Utils {
    
    // Generische Methode zum Ausgeben von Arrays
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.print(element + " ");
        }
        System.out.println();
    }
    
    // Verwendung
    public static void main(String[] args) {
        Integer[] zahlen = {1, 2, 3, 4, 5};
        String[] namen = {"Anna", "Bob", "Clara"};
        
        printArray(zahlen);  // 1 2 3 4 5
        printArray(namen);   // Anna Bob Clara
    }
}
            </div>

            <div class="warning-box">
                <strong>‚ö†Ô∏è Wichtig:</strong> Generics funktionieren nur mit Objekttypen, nicht mit primitiven Typen!<br>
                <strong>Falsch:</strong> ArrayList&lt;int&gt;<br>
                <strong>Richtig:</strong> ArrayList&lt;Integer&gt; (Wrapper-Klasse)
            </div>
        </section>

        <!-- 5. INNERE KLASSEN - NEU -->
        <section class="section">
            <h2>üè† 5. Innere Klassen - Static vs. Non-Static</h2>
            
            <div class="definition-box">
                <strong>Innere Klasse:</strong> Eine Klasse, die innerhalb einer anderen Klasse definiert ist. Es gibt zwei Haupttypen: <strong>static</strong> und <strong>non-static</strong> (innere Klassen).
            </div>

            <h3>üîç Der entscheidende Unterschied</h3>
            
            <div class="comparison-grid">
                <div class="comparison-card">
                    <h4>‚ùå Non-Static Innere Klasse</h4>
                    <div class="code-block">
public class √Ñu√üere {
    private int wert = 42;
    
    // Non-static innere Klasse
    class Innere {
        void zeigen() {
            // ‚úÖ Kann auf wert zugreifen!
            System.out.println(wert);
        }
    }
}

// Verwendung
√Ñu√üere √§u√üere = new √Ñu√üere();
√Ñu√üere.Innere innere = √§u√üere.new Innere();
// Braucht Instanz von √Ñu√üere!
                    </div>
                    <div class="pros-cons">
                        <h5 class="pros">‚úÖ Vorteile:</h5>
                        <ul>
                            <li>Zugriff auf alle Felder der √§u√üeren Klasse</li>
                            <li>Logisch zur Instanz geh√∂rend</li>
                        </ul>
                        <h5 class="cons">‚ùå Nachteile:</h5>
                        <ul>
                            <li>Braucht √§u√üere Instanz</li>
                            <li>Versteckte Referenz (mehr Speicher)</li>
                        </ul>
                    </div>
                </div>
                
                <div class="comparison-card">
                    <h4>‚úÖ Static Innere Klasse</h4>
                    <div class="code-block">
public class √Ñu√üere {
    private int wert = 42;
    
    // Static innere Klasse
    static class Innere {
        void zeigen() {
            // ‚ùå Kann NICHT auf wert zugreifen!
            // System.out.println(wert);
        }
    }
}

// Verwendung
√Ñu√üere.Innere innere = new √Ñu√üere.Innere();
// Braucht KEINE Instanz von √Ñu√üere!
                    </div>
                    <div class="pros-cons">
                        <h5 class="pros">‚úÖ Vorteile:</h5>
                        <ul>
                            <li>Unabh√§ngig von √§u√üerer Instanz</li>
                            <li>Weniger Speicher</li>
                            <li>Kann in static Methoden verwendet werden</li>
                        </ul>
                        <h5 class="cons">‚ùå Nachteile:</h5>
                        <ul>
                            <li>Kein Zugriff auf Instanz-Felder</li>
                        </ul>
                    </div>
                </div>
            </div>

            <h3>üéØ Praktisches Beispiel: Warum Auto static sein muss</h3>
            
            <div class="code-block">
public class Generics<T> {
    private Node<T> head;
    
    // Auto als STATIC - funktioniert in main()
    static class Auto {
        String FGN, Besitzer;
        
        public Auto(String FGN, String Besitzer) {
            this.FGN = FGN;
            this.Besitzer = Besitzer;
        }
        
        @Override
        public String toString() {
            return "Auto[" + FGN + ", " + Besitzer + "]";
        }
    }
    
    public static void main(String[] args) {
        // main ist static!
        // Wir k√∂nnen Auto hier nur nutzen, weil Auto auch static ist
        Generics<Auto> autoListe = new Generics<>();
        autoListe.add(new Auto("MH-AB 123", "Max"));
        autoListe.add(new Auto("MH-CD 456", "Anna"));
    }
}
            </div>

            <div class="example-box">
                <h4>üí° Wann was verwenden?</h4>
                <ul>
                    <li><strong>Non-static:</strong> Wenn die innere Klasse auf Instanz-Felder der √§u√üeren Klasse zugreifen muss</li>
                    <li><strong>Static:</strong> Wenn die innere Klasse unabh√§ngig ist (wie Auto, Node, etc.)</li>
                </ul>
            </div>

            <h3>üìä Vergleichstabelle</h3>
            
            <table class="complexity-table">
                <tr>
                    <th>Aspekt</th>
                    <th>Non-Static</th>
                    <th>Static</th>
                </tr>
                <tr>
                    <td>Braucht √§u√üere Instanz?</td>
                    <td class="complexity-bad">Ja</td>
                    <td class="complexity-good">Nein</td>
                </tr>
                <tr>
                    <td>Zugriff auf Instanz-Felder?</td>
                    <td class="complexity-good">Ja</td>
                    <td class="complexity-bad">Nein</td>
                </tr>
                <tr>
                    <td>Zugriff auf static Felder?</td>
                    <td class="complexity-good">Ja</td>
                    <td class="complexity-good">Ja</td>
                </tr>
                <tr>
                    <td>Verwendbar in static Methoden?</td>
                    <td class="complexity-bad">Nein</td>
                    <td class="complexity-good">Ja</td>
                </tr>
                <tr>
                    <td>Speicherverbrauch</td>
                    <td class="complexity-bad">H√∂her</td>
                    <td class="complexity-good">Niedriger</td>
                </tr>
            </table>
        </section>

        <!-- 6. VERKETTETE LISTEN MIT GENERICS - HAUPTTEIL -->
<section class="section">
    <h2>üîó 6. Verkettete Listen mit Generics - Vollst√§ndig</h2>
    
    <div class="definition-box">
        <strong>Verkettete Liste (Linked List):</strong> Eine dynamische Datenstruktur, bei der Elemente (Knoten) √ºber Zeiger/Referenzen miteinander verbunden sind. Jeder Knoten enth√§lt Daten und einen Verweis auf den n√§chsten Knoten.
    </div>

    <h3>üìê Struktur einer verketteten Liste</h3>
    
    <div class="visual-demo">
        <h4>Visualisierung:</h4>
        <div class="linked-list-visual">
            <div style="font-weight: bold; color: var(--primary-color);">head ‚Üí</div>
            <div class="node-box">
                <div class="node-data">"Hallo"</div>
                <div>‚Üí</div>
            </div>
            <div class="node-box">
                <div class="node-data">"Welt"</div>
                <div>‚Üí</div>
            </div>
            <div class="node-box">
                <div class="node-data">"!"</div>
                <div>‚Üí</div>
            </div>
            <div class="null-box">null</div>
        </div>
        <p style="margin-top: 1rem;">Jeder Knoten hat: <strong>Daten</strong> und <strong>Verweis auf n√§chsten Knoten</strong></p>
    </div>

    <h3>üèóÔ∏è Node-Klasse (Der Baustein)</h3>
    
    <pre><code class="language-java">// Node als innere Klasse
class Node&lt;T&gt; {
    T data;           // Die eigentlichen Daten
    Node&lt;T&gt; next;     // Verweis auf n√§chsten Knoten
    
    public Node(T data) {
        this.data = data;
        this.next = null;
    }
}</code></pre>

    <h3>üíª Vollst√§ndige LinkedList-Implementierung</h3>
    
    <pre><code class="language-java">public class LinkedList&lt;T&gt; {
    private Node&lt;T&gt; head;  // Erstes Element
    private int size;      // Gr√∂√üe der Liste
    
    // ========== INNERE NODE-KLASSE ==========
    private class Node&lt;T&gt; {
        T data;
        Node&lt;T&gt; next;
        
        public Node(T data) {
            this.data = data;
            this.next = null;
        }
    }
    
    // ========== KONSTRUKTOR ==========
    public LinkedList() {
        this.head = null;
        this.size = 0;
    }
    
    // ========== 1. ELEMENT AM ENDE HINZUF√úGEN ==========
    public void add(T element) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(element);
        
        if (head == null) {
            // Liste ist leer
            head = newNode;
        } else {
            // Durchlaufe bis zum letzten Knoten
            Node&lt;T&gt; current = head;
            while (current.next != null) {
                current = current.next;
            }
            current.next = newNode;  // Neuen Knoten anh√§ngen
        }
        size++;
    }
    
    // ========== 2. ELEMENT AM ANFANG HINZUF√úGEN ==========
    public void addFirst(T element) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(element);
        newNode.next = head;  // Neuer Knoten zeigt auf alten head
        head = newNode;       // head wird neuer Knoten
        size++;
    }
    
    // ========== 3. ELEMENT AN POSITION EINF√úGEN ==========
    public void addAt(int index, T element) {
        if (index &lt; 0 || index &gt; size) {
            throw new IndexOutOfBoundsException("Index: " + index);
        }
        
        if (index == 0) {
            addFirst(element);
            return;
        }
        
        Node&lt;T&gt; newNode = new Node&lt;&gt;(element);
        Node&lt;T&gt; current = head;
        
        // Gehe zu Position index-1
        for (int i = 0; i &lt; index - 1; i++) {
            current = current.next;
        }
        
        newNode.next = current.next;
        current.next = newNode;
        size++;
    }
    
    // ========== 4. ELEMENT ENTFERNEN ==========
    public boolean remove(T element) {
        if (head == null) return false;
        
        // Falls erstes Element gel√∂scht werden soll
        if (head.data.equals(element)) {
            head = head.next;
            size--;
            return true;
        }
        
        // Suche Element in der Liste
        Node&lt;T&gt; current = head;
        while (current.next != null) {
            if (current.next.data.equals(element)) {
                current.next = current.next.next;
                size--;
                return true;
            }
            current = current.next;
        }
        
        return false;
    }
    
    // ========== 5. ELEMENT AN INDEX ENTFERNEN ==========
    public T removeAt(int index) {
        if (index &lt; 0 || index &gt;= size) {
            throw new IndexOutOfBoundsException("Index: " + index);
        }
        
        if (index == 0) {
            T data = head.data;
            head = head.next;
            size--;
            return data;
        }
        
        Node&lt;T&gt; current = head;
        for (int i = 0; i &lt; index - 1; i++) {
            current = current.next;
        }
        
        T data = current.next.data;
        current.next = current.next.next;
        size--;
        return data;
    }
    
    // ========== 6. ELEMENT SUCHEN ==========
    public boolean contains(T element) {
        Node&lt;T&gt; current = head;
        while (current != null) {
            if (current.data.equals(element)) {
                return true;
            }
            current = current.next;
        }
        return false;
    }
    
    // ========== 7. ELEMENT AN INDEX ABRUFEN ==========
    public T get(int index) {
        if (index &lt; 0 || index &gt;= size) {
            throw new IndexOutOfBoundsException("Index: " + index);
        }
        
        Node&lt;T&gt; current = head;
        for (int i = 0; i &lt; index; i++) {
            current = current.next;
        }
        return current.data;
    }
    
    // ========== 8. LISTE ANZEIGEN ==========
    public void display() {
        if (head == null) {
            System.out.println("[]");
            return;
        }
        
        Node&lt;T&gt; current = head;
        System.out.print("[");
        while (current != null) {
            System.out.print(current.data);
            if (current.next != null) {
                System.out.print(" -&gt; ");
            }
            current = current.next;
        }
        System.out.println("]");
    }
    
    // ========== 9. GR√ñSSE ==========
    public int size() {
        return size;
    }
    
    // ========== 10. IST LEER? ==========
    public boolean isEmpty() {
        return head == null;
    }
    
    // ========== 11. LISTE LEEREN ==========
    public void clear() {
        head = null;
        size = 0;
    }
}</code></pre>

    <h3>üéÆ Verwendungsbeispiele</h3>
    
    <pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        
        // ===== STRING-LISTE =====
        LinkedList&lt;String&gt; namen = new LinkedList&lt;&gt;();
        namen.add("Anna");
        namen.add("Bob");
        namen.add("Clara");
        namen.addFirst("Zara");  // Am Anfang
        
        System.out.println("Namen:");
        namen.display();  // [Zara -&gt; Anna -&gt; Bob -&gt; Clara]
        
        namen.remove("Bob");
        namen.display();  // [Zara -&gt; Anna -&gt; Clara]
        
        System.out.println("Enth√§lt Anna? " + namen.contains("Anna"));
        System.out.println("Element an Index 1: " + namen.get(1));
        
        
        // ===== INTEGER-LISTE =====
        LinkedList&lt;Integer&gt; zahlen = new LinkedList&lt;&gt;();
        zahlen.add(10);
        zahlen.add(20);
        zahlen.add(30);
        zahlen.addAt(1, 15);  // An Position 1
        
        System.out.println("\nZahlen:");
        zahlen.display();  // [10 -&gt; 15 -&gt; 20 -&gt; 30]
        
        
        // ===== AUTO-LISTE =====
        LinkedList&lt;Auto&gt; autos = new LinkedList&lt;&gt;();
        autos.add(new Auto("MH-AB 123", "Max"));
        autos.add(new Auto("MH-CD 456", "Anna"));
        autos.add(new Auto("MH-EF 789", "Peter"));
        
        System.out.println("\nAutos:");
        autos.display();
        System.out.println("Anzahl: " + autos.size());
    }
    
    // Auto als static innere Klasse
    static class Auto {
        String FGN, Besitzer;
        
        public Auto(String FGN, String Besitzer) {
            this.FGN = FGN;
            this.Besitzer = Besitzer;
        }
        
        @Override
        public String toString() {
            return "Auto[" + FGN + ", " + Besitzer + "]";
        }
    }
}</code></pre>

    <h3>üìä Operationen Visualisiert</h3>
    
    <div class="step-by-step">
        <div class="step">
            <div class="step-number">1</div>
            <div>
                <strong>add("C") - Am Ende hinzuf√ºgen:</strong>
                <div class="visual-demo">
                    <div style="text-align: left; font-family: monospace;">
                        Vorher:  head ‚Üí [A] ‚Üí [B] ‚Üí null<br>
                        Nachher: head ‚Üí [A] ‚Üí [B] ‚Üí [C] ‚Üí null
                    </div>
                </div>
            </div>
        </div>
        
        <div class="step">
            <div class="step-number">2</div>
            <div>
                <strong>addFirst("Z") - Am Anfang hinzuf√ºgen:</strong>
                <div class="visual-demo">
                    <div style="text-align: left; font-family: monospace;">
                        Vorher:  head ‚Üí [A] ‚Üí [B] ‚Üí null<br>
                        Nachher: head ‚Üí [Z] ‚Üí [A] ‚Üí [B] ‚Üí null
                    </div>
                </div>
            </div>
        </div>
        
        <div class="step">
            <div class="step-number">3</div>
            <div>
                <strong>addAt(1, "X") - An Position 1:</strong>
                <div class="visual-demo">
                    <div style="text-align: left; font-family: monospace;">
                        Vorher:  head ‚Üí [A] ‚Üí [B] ‚Üí [C] ‚Üí null<br>
                        Nachher: head ‚Üí [A] ‚Üí [X] ‚Üí [B] ‚Üí [C] ‚Üí null
                    </div>
                </div>
            </div>
        </div>
        
        <div class="step">
            <div class="step-number">4</div>
            <div>
                <strong>remove("B") - Element entfernen:</strong>
                <div class="visual-demo">
                    <div style="text-align: left; font-family: monospace;">
                        Vorher:  head ‚Üí [A] ‚Üí [B] ‚Üí [C] ‚Üí null<br>
                        Nachher: head ‚Üí [A] ‚Üí [C] ‚Üí null
                    </div>
                </div>
            </div>
        </div>
    </div>

    <h3>‚öñÔ∏è Vorteile vs. Nachteile</h3>
    
    <div class="comparison-grid">
        <div class="comparison-card">
            <h4 class="pros">‚úÖ Vorteile</h4>
            <ul>
                <li>Dynamische Gr√∂√üe (w√§chst nach Bedarf)</li>
                <li>Effizientes Einf√ºgen/L√∂schen am Anfang: O(1)</li>
                <li>Kein Verschieben von Elementen n√∂tig</li>
                <li>Mit Generics typsicher f√ºr alle Typen</li>
            </ul>
        </div>
        <div class="comparison-card">
            <h4 class="cons">‚ùå Nachteile</h4>
            <ul>
                <li>Langsamer Zugriff auf Elemente: O(n)</li>
                <li>Mehr Speicher (jeder Node braucht extra Platz)</li>
                <li>Kein direkter Index-Zugriff wie bei Arrays</li>
                <li>Komplexer als Arrays</li>
            </ul>
        </div>
    </div>

    <h3>‚è±Ô∏è Zeitkomplexit√§t</h3>
    
    <table class="complexity-table">
        <tr>
            <th>Operation</th>
            <th>Zeitkomplexit√§t</th>
            <th>Erkl√§rung</th>
        </tr>
        <tr class="complexity-bad">
            <td>add() (am Ende)</td>
            <td>O(n)</td>
            <td>Muss bis zum Ende durchlaufen</td>
        </tr>
        <tr class="complexity-good">
            <td>addFirst()</td>
            <td>O(1)</td>
            <td>Direkt am Anfang einf√ºgen</td>
        </tr>
        <tr class="complexity-bad">
            <td>addAt(index)</td>
            <td>O(n)</td>
            <td>Muss bis zum Index durchlaufen</td>
        </tr>
        <tr class="complexity-bad">
            <td>remove()</td>
            <td>O(n)</td>
            <td>Muss Element suchen</td>
        </tr>
        <tr class="complexity-bad">
            <td>get(index)</td>
            <td>O(n)</td>
            <td>Muss bis zum Index durchlaufen</td>
        </tr>
        <tr class="complexity-bad">
            <td>contains()</td>
            <td>O(n)</td>
            <td>Muss gesamte Liste durchsuchen</td>
        </tr>
    </table>

    <div class="example-box">
        <h4>üí° Doppelt verkettete Liste</h4>
        <p>Eine Erweiterung: Jeder Knoten hat auch einen Verweis auf den <strong>vorherigen</strong> Knoten.</p>
        <pre><code class="language-java">class Node&lt;T&gt; {
    T data;
    Node&lt;T&gt; next;
    Node&lt;T&gt; prev;  // NEU: Verweis auf vorherigen Knoten
}</code></pre>
        <div class="visual-demo">
            <div style="font-family: monospace;">
                null ‚Üê [A] ‚áÑ [B] ‚áÑ [C] ‚Üí null
            </div>
        </div>
        <p><strong>Vorteil:</strong> Kann in beide Richtungen durchlaufen werden!</p>
    </div>
</section>

        <!-- 7. Stack & Queue (gek√ºrzt) -->
        <section class="section">
            <h2>üìö 7. Stack & Queue - LIFO und FIFO</h2>
            
            <h3>ü•û Stack (Stapel) - LIFO</h3>
            
            <div class="definition-box">
                <strong>Stack:</strong> Last In, First Out - Wie ein Stapel Teller, das zuletzt draufgelegte wird zuerst weggenommen.
            </div>

            <div class="visual-demo">
                <div class="stack-demo">
                    <div class="stack-item">Element 3 (Top)</div>
                    <div class="stack-item">Element 2</div>
                    <div class="stack-item">Element 1 (Bottom)</div>
                </div>
                <p><strong>push():</strong> Oben drauflegen | <strong>pop():</strong> Oberstes entfernen</p>
            </div>

            <h3>üöå Queue (Warteschlange) - FIFO</h3>
            
            <div class="definition-box">
                <strong>Queue:</strong> First In, First Out - Wie eine Warteschlange, wer zuerst kommt wird zuerst bedient.
            </div>

            <div class="visual-demo">
                <div class="queue-demo">
                    <div class="queue-item">Erste</div>
                    <div class="queue-item">‚Üí</div>
                    <div class="queue-item">Zweite</div>
                    <div class="queue-item">‚Üí</div>
                    <div class="queue-item">Dritte</div>
                </div>
                <p><strong>enqueue():</strong> Hinten anstellen | <strong>dequeue():</strong> Vorne entfernen</p>
            </div>
        </section>

        <!-- 8. Java Collections Framework (MASSIV ERWEITERT) -->
        <section class="section">
            <h2>üìö 8. Java Collections Framework (JCF) - Komplett</h2>
            
            <div class="definition-box">
                <strong>Java Collections Framework:</strong> Umfangreiche Sammlung von Datenstrukturen im Package java.util. Alle arbeiten mit Objekten (Wrapper-Klassen f√ºr primitive Typen wie Integer, Double, Boolean statt int, double, boolean).
            </div>

            <div class="intro-box">
                <h3>üéØ √úberblick</h3>
                <p>Das JCF bietet fertige, optimierte Implementierungen f√ºr alle wichtigen Datenstrukturen. Du musst nicht selbst eine verkettete Liste programmieren - nutze einfach die Java-Klassen!</p>
            </div>

            <h3>üìä √úbersichtstabelle - Alle Collections</h3>
            
            <table class="complexity-table">
                <tr>
                    <th>Klasse</th>
                    <th>Typ</th>
                    <th>Sortiert</th>
                    <th>Duplikate</th>
                    <th>Wann verwenden?</th>
                </tr>
                <tr>
                    <td><strong>ArrayList</strong></td>
                    <td>List</td>
                    <td>‚ùå</td>
                    <td>‚úÖ</td>
                    <td>H√§ufiger Index-Zugriff</td>
                </tr>
                <tr>
                    <td><strong>LinkedList</strong></td>
                    <td>List</td>
                    <td>‚ùå</td>
                    <td>‚úÖ</td>
                    <td>H√§ufiges Einf√ºgen/L√∂schen</td>
                </tr>
                <tr>
                    <td><strong>HashSet</strong></td>
                    <td>Set</td>
                    <td>‚ùå</td>
                    <td>‚ùå</td>
                    <td>Eindeutige Elemente, schnell</td>
                </tr>
                <tr>
                    <td><strong>TreeSet</strong></td>
                    <td>SortedSet</td>
                    <td>‚úÖ</td>
                    <td>‚ùå</td>
                    <td>Sortierte eindeutige Elemente</td>
                </tr>
                <tr>
                    <td><strong>HashMap</strong></td>
                    <td>Map</td>
                    <td>‚ùå</td>
                    <td>Werte: ‚úÖ</td>
                    <td>Key-Value Paare, schnell</td>
                </tr>
                <tr>
                    <td><strong>TreeMap</strong></td>
                    <td>SortedMap</td>
                    <td>‚úÖ</td>
                    <td>Werte: ‚úÖ</td>
                    <td>Sortierte Key-Value Paare</td>
                </tr>
            </table>

            <!-- ========== ARRAYLIST ========== -->
            <h3>1Ô∏è‚É£ ArrayList - Die dynamische Liste</h3>
            
            <div class="definition-box">
                <strong>ArrayList&lt;E&gt;:</strong> Eine dynamische Liste, die intern ein Array verwendet. Die Gr√∂√üe passt sich automatisch an. Optimal f√ºr h√§ufigen Zugriff √ºber Index.
            </div>

            <div class="algorithm-comparison">
                <div class="algorithm-card">
                    <h4>üìã Eigenschaften</h4>
                    <ul>
                        <li>‚úÖ Implementiert List Interface</li>
                        <li>‚úÖ Duplikate erlaubt</li>
                        <li>‚úÖ Reihenfolge bleibt erhalten</li>
                        <li>‚úÖ Schneller Index-Zugriff O(1)</li>
                        <li>‚ùå Nicht sortiert</li>
                        <li>‚ùå Langsames Einf√ºgen in der Mitte</li>
                    </ul>
                </div>
                <div class="algorithm-card">
                    <h4>üéØ Wann verwenden?</h4>
                    <ul>
                        <li>H√§ufiger Lesezugriff</li>
                        <li>Zugriff √ºber Index wichtig</li>
                        <li>Elemente meist am Ende hinzuf√ºgen</li>
                        <li>Nicht viel Einf√ºgen/L√∂schen in der Mitte</li>
                    </ul>
                </div>
            </div>

            <h4>üíª ArrayList Beispiele</h4>
            
            <div class="code-block">
import java.util.ArrayList;

public class ArrayListBeispiel {
    public static void main(String[] args) {
        // ArrayList erstellen
        ArrayList<String> namen = new ArrayList<>();
        
        // ===== ELEMENTE HINZUF√úGEN =====
        namen.add("Anna");           // Am Ende hinzuf√ºgen
        namen.add("Bob");
        namen.add("Clara");
        namen.add(1, "Zara");        // An Index 1 einf√ºgen
        
        System.out.println(namen);   // [Anna, Zara, Bob, Clara]
        
        // ===== ZUGRIFF =====
        String erster = namen.get(0);              // "Anna"
        int groesse = namen.size();                 // 4
        boolean enthaelt = namen.contains("Bob");   // true
        int index = namen.indexOf("Clara");         // 3
        
        // ===== √ÑNDERN =====
        namen.set(1, "Max");         // Ersetze Index 1
        System.out.println(namen);   // [Anna, Max, Bob, Clara]
        
        // ===== L√ñSCHEN =====
        namen.remove("Bob");         // L√∂sche "Bob"
        namen.remove(0);             // L√∂sche Index 0
        System.out.println(namen);   // [Max, Clara]
        
        // ===== DURCHLAUFEN =====
        // Mit for-Schleife
        for (int i = 0; i < namen.size(); i++) {
            System.out.println(namen.get(i));
        }
        
        // Mit enhanced for
        for (String name : namen) {
            System.out.println(name);
        }
        
        // ===== WEITERE METHODEN =====
        namen.clear();               // Alles l√∂schen
        boolean leer = namen.isEmpty();  // true
    }
}
            </div>

            <div class="example-box">
                <h4>üéì Praktisches Beispiel: Sch√ºlerliste</h4>
                <div class="code-block">
ArrayList<String> schueler = new ArrayList<>();
schueler.add("Max Mustermann");
schueler.add("Anna Schmidt");
schueler.add("Peter M√ºller");

// Note zuordnen (parallel ArrayList)
ArrayList<Double> noten = new ArrayList<>();
noten.add(2.3);
noten.add(1.7);
noten.add(2.0);

// Ausgabe
for (int i = 0; i < schueler.size(); i++) {
    System.out.println(schueler.get(i) + ": " + noten.get(i));
}
// Output:
// Max Mustermann: 2.3
// Anna Schmidt: 1.7
// Peter M√ºller: 2.0
                </div>
            </div>

            <div class="warning-box">
                <strong>‚ö†Ô∏è ArrayList vs. Array:</strong><br>
                ‚Ä¢ Array: Feste Gr√∂√üe, schnell, <code>int[] arr = new int[5];</code><br>
                ‚Ä¢ ArrayList: Dynamische Gr√∂√üe, flexibel, <code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code>
            </div>

            <!-- ========== LINKEDLIST ========== -->
            <h3>2Ô∏è‚É£ LinkedList - Die verkettete Liste</h3>
            
            <div class="definition-box">
                <strong>LinkedList&lt;E&gt;:</strong> Implementiert sowohl List als auch Deque. Intern als doppelt verkettete Liste. Optimal f√ºr h√§ufiges Einf√ºgen/L√∂schen.
            </div>

            <div class="algorithm-comparison">
                <div class="algorithm-card">
                    <h4>üìã Eigenschaften</h4>
                    <ul>
                        <li>‚úÖ Implementiert List UND Deque</li>
                        <li>‚úÖ Duplikate erlaubt</li>
                        <li>‚úÖ Schnelles Einf√ºgen/L√∂schen O(1)</li>
                        <li>‚úÖ Kann als Stack oder Queue verwendet werden</li>
                        <li>‚ùå Langsamer Index-Zugriff O(n)</li>
                        <li>‚ùå Mehr Speicher pro Element</li>
                    </ul>
                </div>
                <div class="algorithm-card">
                    <h4>üéØ Wann verwenden?</h4>
                    <ul>
                        <li>H√§ufiges Einf√ºgen/L√∂schen</li>
                        <li>Am Anfang/Ende arbeiten wichtig</li>
                        <li>Als Queue oder Stack nutzen</li>
                        <li>Index-Zugriff unwichtig</li>
                    </ul>
                </div>
            </div>

            <h4>üíª LinkedList Beispiele</h4>
            
            <div class="code-block">
import java.util.LinkedList;

public class LinkedListBeispiel {
    public static void main(String[] args) {
        LinkedList<String> liste = new LinkedList<>();
        
        // ===== ELEMENTE HINZUF√úGEN =====
        liste.add("A");              // Am Ende
        liste.add("B");
        liste.addFirst("Z");         // Am Anfang ‚ö° O(1)
        liste.addLast("Y");          // Am Ende ‚ö° O(1)
        
        System.out.println(liste);   // [Z, A, B, Y]
        
        // ===== ERSTES/LETZTES ELEMENT =====
        String erstes = liste.getFirst();   // "Z"
        String letztes = liste.getLast();   // "Y"
        
        // ===== ENTFERNEN =====
        liste.removeFirst();         // Entfernt "Z" ‚ö° O(1)
        liste.removeLast();          // Entfernt "Y" ‚ö° O(1)
        System.out.println(liste);   // [A, B]
        
        // ===== ALS QUEUE (Warteschlange) =====
        LinkedList<String> queue = new LinkedList<>();
        queue.offer("Kunde 1");      // Hinten anstellen
        queue.offer("Kunde 2");
        queue.offer("Kunde 3");
        
        String bedient = queue.poll();  // Vorne entfernen
        System.out.println("Bedient: " + bedient);  // "Kunde 1"
        
        // ===== ALS STACK (Stapel) =====
        LinkedList<String> stack = new LinkedList<>();
        stack.push("Teller 1");      // Oben drauf
        stack.push("Teller 2");
        stack.push("Teller 3");
        
        String oben = stack.pop();   // Oberstes entfernen
        System.out.println("Oben: " + oben);  // "Teller 3"
    }
}
            </div>

            <div class="example-box">
                <h4>üéì Praktisches Beispiel: Undo-Funktion</h4>
                <div class="code-block">
// LinkedList als Stack f√ºr Undo
LinkedList<String> aktionen = new LinkedList<>();

// Aktionen durchf√ºhren
aktionen.push("Text geschrieben");
aktionen.push("Bild eingef√ºgt");
aktionen.push("Formatierung ge√§ndert");

// Undo (letzte Aktion r√ºckg√§ngig)
String letzteAktion = aktionen.pop();
System.out.println("R√ºckg√§ngig: " + letzteAktion);
// Output: R√ºckg√§ngig: Formatierung ge√§ndert

// N√§chstes Undo
String vorletzteAktion = aktionen.pop();
System.out.println("R√ºckg√§ngig: " + vorletzteAktion);
// Output: R√ºckg√§ngig: Bild eingef√ºgt
                </div>
            </div>

            <h4>‚öñÔ∏è ArrayList vs. LinkedList</h4>
            
            <table class="complexity-table">
                <tr>
                    <th>Operation</th>
                    <th>ArrayList</th>
                    <th>LinkedList</th>
                </tr>
                <tr>
                    <td>get(index)</td>
                    <td class="complexity-good">O(1) ‚úÖ</td>
                    <td class="complexity-bad">O(n) ‚ùå</td>
                </tr>
                <tr>
                    <td>add() am Ende</td>
                    <td class="complexity-good">O(1) ‚úÖ</td>
                    <td class="complexity-good">O(1) ‚úÖ</td>
                </tr>
                <tr>
                    <td>add(0, element)</td>
                    <td class="complexity-bad">O(n) ‚ùå</td>
                    <td class="complexity-good">O(1) ‚úÖ</td>
                </tr>
                <tr>
                    <td>remove(index)</td>
                    <td class="complexity-bad">O(n) ‚ùå</td>
                    <td class="complexity-bad">O(n) ~</td>
                </tr>
                <tr>
                    <td>Speicher</td>
                    <td class="complexity-good">Weniger ‚úÖ</td>
                    <td class="complexity-bad">Mehr ‚ùå</td>
                </tr>
            </table>

            <!-- ========== HASHSET ========== -->
            <h3>3Ô∏è‚É£ HashSet - Eindeutige Elemente, blitzschnell</h3>
            
            <div class="definition-box">
                <strong>HashSet&lt;E&gt;:</strong> Speichert eindeutige Elemente ohne bestimmte Reihenfolge. Verwendet Hashing f√ºr extrem schnelle Operationen.
            </div>

            <div class="algorithm-comparison">
                <div class="algorithm-card">
                    <h4>üìã Eigenschaften</h4>
                    <ul>
                        <li>‚úÖ Implementiert Set Interface</li>
                        <li>‚ùå Keine Duplikate!</li>
                        <li>‚ùå Keine geordnete Reihenfolge</li>
                        <li>‚úÖ Sehr schnell: add(), remove(), contains() = O(1)</li>
                        <li>‚ùå Kein Index-Zugriff</li>
                        <li>‚ùå Erlaubt max. ein <code>null</code> Element</li>
                    </ul>
                </div>
                <div class="algorithm-card">
                    <h4>üéØ Wann verwenden?</h4>
                    <ul>
                        <li>Duplikate verhindern wichtig</li>
                        <li>Sehr schnelles Suchen n√∂tig</li>
                        <li>Reihenfolge egal</li>
                        <li>Mitgliedschaftstest (contains)</li>
                    </ul>
                </div>
            </div>

            <h4>üíª HashSet Beispiele</h4>
            
            <div class="code-block">
import java.util.HashSet;

public class HashSetBeispiel {
    public static void main(String[] args) {
        HashSet<String> set = new HashSet<>();
        
        // ===== ELEMENTE HINZUF√úGEN =====
        set.add("Apfel");
        set.add("Banane");
        set.add("Orange");
        set.add("Apfel");       // Duplikat - wird ignoriert!
        
        System.out.println(set);
        // Output: [Orange, Banane, Apfel] (Reihenfolge variiert!)
        
        System.out.println("Gr√∂√üe: " + set.size());  // 3 (nicht 4!)
        
        // ===== PR√úFEN =====
        boolean hatApfel = set.contains("Apfel");    // true ‚ö° O(1)
        boolean hatKiwi = set.contains("Kiwi");      // false ‚ö° O(1)
        
        // ===== ENTFERNEN =====
        set.remove("Banane");    // Entfernt "Banane" ‚ö° O(1)
        
        // ===== DURCHLAUFEN =====
        for (String frucht : set) {
            System.out.println(frucht);
        }
        
        // ===== SET-OPERATIONEN =====
        HashSet<Integer> a = new HashSet<>();
        a.add(1); a.add(2); a.add(3);
        
        HashSet<Integer> b = new HashSet<>();
        b.add(2); b.add(3); b.add(4);
        
        // Vereinigung (Union)
        HashSet<Integer> union = new HashSet<>(a);
        union.addAll(b);
        System.out.println("Union: " + union);  // [1, 2, 3, 4]
        
        // Schnittmenge (Intersection)
        HashSet<Integer> intersection = new HashSet<>(a);
        intersection.retainAll(b);
        System.out.println("Schnittmenge: " + intersection);  // [2, 3]
        
        // Differenz
        HashSet<Integer> diff = new HashSet<>(a);
        diff.removeAll(b);
        System.out.println("Differenz: " + diff);  // [1]
    }
}
            </div>

            <div class="example-box">
                <h4>üéì Praktisches Beispiel: Duplikate entfernen</h4>
                <div class="code-block">
// Duplikate aus einer Liste entfernen
ArrayList<String> listeMitDuplikaten = new ArrayList<>();
listeMitDuplikaten.add("Rot");
listeMitDuplikaten.add("Blau");
listeMitDuplikaten.add("Rot");
listeMitDuplikaten.add("Gr√ºn");
listeMitDuplikaten.add("Blau");

System.out.println("Mit Duplikaten: " + listeMitDuplikaten);
// [Rot, Blau, Rot, Gr√ºn, Blau]

// In HashSet konvertieren (entfernt automatisch Duplikate)
HashSet<String> ohneDuplikate = new HashSet<>(listeMitDuplikaten);

System.out.println("Ohne Duplikate: " + ohneDuplikate);
// [Rot, Gr√ºn, Blau] (Reihenfolge variiert)

// Zur√ºck in ArrayList (falls Reihenfolge egal)
ArrayList<String> liste = new ArrayList<>(ohneDuplikate);
                </div>
            </div>

            <div class="warning-box">
                <strong>‚ö†Ô∏è HashSet Besonderheit:</strong><br>
                Die Reihenfolge der Elemente ist NICHT garantiert und kann sich √§ndern! Wenn du Reihenfolge brauchst, nutze <code>LinkedHashSet</code> (beh√§lt Einf√ºge-Reihenfolge) oder <code>TreeSet</code> (sortiert).
            </div>

            <!-- ========== TREESET ========== -->
            <h3>4Ô∏è‚É£ TreeSet - Sortierte eindeutige Elemente</h3>
            
            <div class="definition-box">
                <strong>TreeSet&lt;E&gt;:</strong> Speichert eindeutige Elemente in <strong>sortierter</strong> Reihenfolge. Basiert auf einem Red-Black-Tree (balancierter Bin√§rbaum).
            </div>

            <div class="algorithm-comparison">
                <div class="algorithm-card">
                    <h4>üìã Eigenschaften</h4>
                    <ul>
                        <li>‚úÖ Implementiert SortedSet</li>
                        <li>‚ùå Keine Duplikate</li>
                        <li>‚úÖ Automatisch sortiert!</li>
                        <li>‚úÖ Operationen: O(log n)</li>
                        <li>‚ùå Langsamer als HashSet</li>
                        <li>‚ùå Kein <code>null</code> erlaubt</li>
                    </ul>
                </div>
                <div class="algorithm-card">
                    <h4>üéØ Wann verwenden?</h4>
                    <ul>
                        <li>Elemente m√ºssen sortiert sein</li>
                        <li>Keine Duplikate gew√ºnscht</li>
                        <li>Bereich-Operationen (first, last)</li>
                        <li>Navigation durch Elemente</li>
                    </ul>
                </div>
            </div>

            <h4>üíª TreeSet Beispiele</h4>
            
            <div class="code-container">
    <pre><code>import java.util.TreeSet;

public class TreeSetBeispiel {
    public static void main(String[] args) {
        TreeSet&lt;Integer&gt; zahlen = new TreeSet&lt;&gt;();
        
        // ===== ELEMENTE HINZUF√úGEN =====
        zahlen.add(50);
        zahlen.add(20);
        zahlen.add(80);
        zahlen.add(10);
        zahlen.add(20);  // Duplikat - ignoriert!
        
        System.out.println(zahlen);
        // Output: [10, 20, 50, 80] - AUTOMATISCH SORTIERT! ‚ú®
        
        // ===== NAVIGATIONSMETHODEN =====
        int erstes = zahlen.first();           // 10 (kleinstes)
        int letztes = zahlen.last();           // 80 (gr√∂√ütes)
        int kleinerAls50 = zahlen.lower(50);   // 20
        int gr√∂√üerAls50 = zahlen.higher(50);   // 80
        
        // ===== TEILMENGEN =====
        // Alle Elemente kleiner als 50
        TreeSet&lt;Integer&gt; kleineTeil = new TreeSet&lt;&gt;(zahlen.headSet(50));
        System.out.println("&lt; 50: " + kleineTeil);  // [10, 20]
        
        // Alle Elemente gr√∂√üer/gleich 50
        TreeSet&lt;Integer&gt; gro√üeTeil = new TreeSet&lt;&gt;(zahlen.tailSet(50));
        System.out.println("&gt;= 50: " + gro√üeTeil);  // [50, 80]
        
        // Bereich von-bis
        TreeSet&lt;Integer&gt; bereich = new TreeSet&lt;&gt;(zahlen.subSet(20, 80));
        System.out.println("20-80: " + bereich);  // [20, 50]
        
        // ===== MIT STRINGS =====
        TreeSet&lt;String&gt; namen = new TreeSet&lt;&gt;();
        namen.add("Zara");
        namen.add("Anna");
        namen.add("Bob");
        namen.add("Max");
        
        System.out.println(namen);
        // Output: [Anna, Bob, Max, Zara] - alphabetisch sortiert!
    }
}

// üéì Praktisches Beispiel: Rangliste
// Spieler-Scores automatisch sortiert
TreeSet&lt;Integer&gt; highscores = new TreeSet&lt;&gt;();
highscores.add(1500);
highscores.add(2300);
highscores.add(1800);
highscores.add(900);
highscores.add(2100);

System.out.println("Rangliste (aufsteigend): " + highscores);
// [900, 1500, 1800, 2100, 2300]

// Top 3 (die h√∂chsten)
System.out.println("3. Platz: " + highscores.pollLast());  // 2300
System.out.println("2. Platz: " + highscores.pollLast());  // 2100
System.out.println("1. Platz: " + highscores.pollLast());  // 1800

// Oder mit descendingSet() f√ºr absteigende Sortierung
TreeSet&lt;Integer&gt; absteigend = (TreeSet&lt;Integer&gt;) highscores.descendingSet();</code></pre>
</div>

            <div class="warning-box">
                <strong>‚ö†Ô∏è TreeSet Voraussetzung:</strong><br>
                Elemente m√ºssen <strong>vergleichbar</strong> sein (Comparable implementieren) oder du musst einen Comparator angeben!<br>
                F√ºr eigene Klassen: <code>class Person implements Comparable&lt;Person&gt;</code>
            </div>

            <!-- ========== HASHMAP ========== -->
            <h3>5Ô∏è‚É£ HashMap - Key-Value Paare, superschnell</h3>
            
            <div class="definition-box">
                <strong>HashMap&lt;K, V&gt;:</strong> Speichert Daten als Schl√ºssel-Wert-Paare (Key-Value). Jeder Schl√ºssel ist eindeutig und f√ºhrt zu genau einem Wert. Verwendet Hashing f√ºr maximale Geschwindigkeit.
            </div>

            <div class="algorithm-comparison">
                <div class="algorithm-card">
                    <h4>üìã Eigenschaften</h4>
                    <ul>
                        <li>‚úÖ Implementiert Map Interface</li>
                        <li>‚ùå Schl√ºssel eindeutig, Werte d√ºrfen doppelt vorkommen</li>
                        <li>‚ùå Keine Reihenfolge</li>
                        <li>‚úÖ Sehr schnell: put(), get(), remove() = O(1)</li>
                        <li>‚úÖ Ein <code>null</code>-Schl√ºssel erlaubt</li>
                        <li>‚úÖ Mehrere <code>null</code>-Werte erlaubt</li>
                    </ul>
                </div>
                <div class="algorithm-card">
                    <h4>üéØ Wann verwenden?</h4>
                    <ul>
                        <li>Zuordnung von Schl√ºssel zu Wert</li>
                        <li>Sehr schneller Zugriff n√∂tig</li>
                        <li>Reihenfolge egal</li>
                        <li>Nachschlagen in "Tabellen"</li>
                    </ul>
                </div>
            </div>

            <h4>üíª HashMap Beispiele</h4>
            
            <div class="code-block">
import java.util.HashMap;
import java.util.Map;

public class HashMapBeispiel {
    public static void main(String[] args) {
        HashMap<String, Integer> alter = new HashMap<>();
        
        // ===== KEY-VALUE PAARE HINZUF√úGEN =====
        alter.put("Anna", 25);
        alter.put("Bob", 30);
        alter.put("Clara", 28);
        alter.put("Anna", 26);     // √úberschreibt alten Wert!
        
        System.out.println(alter);
        // {Bob=30, Clara=28, Anna=26} (Reihenfolge variiert)
        
        // ===== WERTE ABRUFEN =====
        int annasAlter = alter.get("Anna");           // 26 ‚ö° O(1)
        int standard = alter.getOrDefault("Max", 0);  // 0 (nicht vorhanden)
        
        // ===== PR√úFEN =====
        boolean hatBob = alter.containsKey("Bob");     // true
        boolean hat30 = alter.containsValue(30);       // true
        
        // ===== ENTFERNEN =====
        alter.remove("Bob");
        
        // ===== DURCHLAUFEN =====
        // √úber Keys
        for (String name : alter.keySet()) {
            System.out.println(name);
        }
        
        // √úber Values
        for (Integer a : alter.values()) {
            System.out.println(a);
        }
        
        // √úber Key-Value-Paare (beste Methode!)
        for (Map.Entry<String, Integer> entry : alter.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        // Output:
        // Clara: 28
        // Anna: 26
        
        // ===== GR√ñSSE =====
        int anzahl = alter.size();
        boolean leer = alter.isEmpty();
    }
}
            </div>

            <div class="example-box">
                <h4>üéì Praktisches Beispiel 1: W√∂rterbuch</h4>
                <div class="code-block">
// Deutsch-Englisch W√∂rterbuch
HashMap<String, String> woerterbuch = new HashMap<>();

woerterbuch.put("Haus", "house");
woerterbuch.put("Auto", "car");
woerterbuch.put("Baum", "tree");
woerterbuch.put("Hund", "dog");

// √úbersetzen
String wort = "Auto";
String uebersetzung = woerterbuch.get(wort);
System.out.println(wort + " auf Englisch: " + uebersetzung);
// Output: Auto auf Englisch: car

// Alle √úbersetzungen
for (Map.Entry<String, String> entry : woerterbuch.entrySet()) {
    System.out.println(entry.getKey() + " = " + entry.getValue());
}
                </div>
            </div>

            <div class="example-box">
                <h4>üéì Praktisches Beispiel 2: Buchstaben z√§hlen</h4>
                <div class="code-block">
String text = "hallo welt";
HashMap<Character, Integer> haeufigkeit = new HashMap<>();

// Buchstaben z√§hlen
for (char c : text.toCharArray()) {
    if (c != ' ') {  // Leerzeichen ignorieren
        haeufigkeit.put(c, haeufigkeit.getOrDefault(c, 0) + 1);
    }
}

System.out.println(haeufigkeit);
// {a=1, e=1, h=1, l=3, o=1, t=1, w=1}

// H√§ufigster Buchstabe
int maxCount = 0;
char haeufigster = ' ';
for (Map.Entry<Character, Integer> entry : haeufigkeit.entrySet()) {
    if (entry.getValue() > maxCount) {
        maxCount = entry.getValue();
        haeufigster = entry.getKey();
    }
}

System.out.println("H√§ufigster Buchstabe: " + haeufigster);
// Output: H√§ufigster Buchstabe: l
                </div>
            </div>

            <div class="example-box">
                <h4>üéì Praktisches Beispiel 3: Sch√ºler-Noten</h4>
                <div class="code-block">
// Sch√ºler ‚Üí Note
HashMap<String, Double> noten = new HashMap<>();

noten.put("Max Mustermann", 2.3);
noten.put("Anna Schmidt", 1.7);
noten.put("Peter M√ºller", 2.0);
noten.put("Lisa Wagner", 1.3);

// Durchschnitt berechnen
double summe = 0;
for (Double note : noten.values()) {
    summe += note;
}
double durchschnitt = summe / noten.size();
System.out.println("Notendurchschnitt: " + durchschnitt);

// Beste Note
double beste = Double.MAX_VALUE;
String besterSchueler = "";
for (Map.Entry<String, Double> entry : noten.entrySet()) {
    if (entry.getValue() < beste) {
        beste = entry.getValue();
        besterSchueler = entry.getKey();
    }
}
System.out.println("Beste Note: " + besterSchueler + " mit " + beste);
                </div>
            </div>

            <!-- ========== TREEMAP ========== -->
            <h3>6Ô∏è‚É£ TreeMap - Sortierte Key-Value Paare</h3>
            
            <div class="definition-box">
                <strong>TreeMap&lt;K, V&gt;:</strong> Wie HashMap, aber die Schl√ºssel werden automatisch sortiert gespeichert. Basiert auf einem Red-Black-Tree.
            </div>

            <div class="algorithm-comparison">
                <div class="algorithm-card">
                    <h4>üìã Eigenschaften</h4>
                    <ul>
                        <li>‚úÖ Implementiert SortedMap</li>
                        <li>‚ùå Schl√ºssel eindeutig</li>
                        <li>‚úÖ Nach Schl√ºsseln sortiert!</li>
                        <li>‚úÖ Operationen: O(log n)</li>
                        <li>‚ùå Langsamer als HashMap</li>
                        <li>‚ùå Kein <code>null</code> als Schl√ºssel</li>
                    </ul>
                </div>
                <div class="algorithm-card">
                    <h4>üéØ Wann verwenden?</h4>
                    <ul>
                        <li>Schl√ºssel m√ºssen sortiert sein</li>
                        <li>Navigation durch Keys wichtig</li>
                        <li>Bereich-Operationen n√∂tig</li>
                        <li>Geordnete Key-Value Zuordnung</li>
                    </ul>
                </div>
            </div>

            <h4>üíª TreeMap Beispiele</h4>
            
            <div class="code-block">
import java.util.TreeMap;
import java.util.Map;

public class TreeMapBeispiel {
    public static void main(String[] args) {
        TreeMap<String, Integer> punkte = new TreeMap<>();
        
        // ===== KEY-VALUE PAARE HINZUF√úGEN =====
        punkte.put("Zara", 95);
        punkte.put("Anna", 87);
        punkte.put("Max", 92);
        punkte.put("Bob", 78);
        
        System.out.println(punkte);
        // Output: {Anna=87, Bob=78, Max=92, Zara=95}
        // ‚ú® Automatisch nach Namen (Schl√ºssel) sortiert!
        
        // ===== NAVIGATIONSMETHODEN =====
        String ersterKey = punkte.firstKey();    // "Anna"
        String letzterKey = punkte.lastKey();    // "Zara"
        
        Map.Entry<String, Integer> erstesEntry = punkte.firstEntry();
        System.out.println(erstesEntry.getKey() + ": " + erstesEntry.getValue());
        // Anna: 87
        
        // ===== TEILBEREICHE =====
        // Alle bis "Max" (exklusiv)
        TreeMap<String, Integer> vorMax = 
            new TreeMap<>(punkte.headMap("Max"));
        System.out.println("Vor Max: " + vorMax);
        // {Anna=87, Bob=78}
        
        // Alle ab "Max" (inklusiv)
        TreeMap<String, Integer> abMax = 
            new TreeMap<>(punkte.tailMap("Max"));
        System.out.println("Ab Max: " + abMax);
        // {Max=92, Zara=95}
        
        // ===== MIT ZAHLEN ALS SCHL√úSSEL =====
        TreeMap<Integer, String> rang = new TreeMap<>();
        rang.put(1, "Gold");
        rang.put(3, "Bronze");
        rang.put(2, "Silber");
        
        System.out.println(rang);
        // {1=Gold, 2=Silber, 3=Bronze} - nach Rang sortiert!
        
        // Durchlaufen (bereits sortiert!)
        for (Map.Entry<Integer, String> entry : rang.entrySet()) {
            System.out.println("Platz " + entry.getKey() + ": " + entry.getValue());
        }
        // Platz 1: Gold
        // Platz 2: Silber
        // Platz 3: Bronze
    }
}
            </div>

            <div class="example-box">
                <h4>üéì Praktisches Beispiel: Termine sortiert</h4>
                <div class="code-block">
// Termine automatisch nach Datum sortiert
TreeMap<String, String> termine = new TreeMap<>();

termine.put("2024-03-15", "Zahnarzt");
termine.put("2024-01-10", "Friseur");
termine.put("2024-02-20", "Geburtstag");
termine.put("2024-01-05", "Meeting");

// Ausgabe (automatisch chronologisch!)
for (Map.Entry<String, String> entry : termine.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}
// Output:
// 2024-01-05: Meeting
// 2024-01-10: Friseur
// 2024-02-20: Geburtstag
// 2024-03-15: Zahnarzt

// N√§chster Termin
Map.Entry<String, String> naechster = termine.firstEntry();
System.out.println("N√§chster Termin: " + naechster.getValue() + 
                   " am " + naechster.getKey());
                </div>
            </div>

            <!-- ========== VERGLEICH ALLER MAPS ========== -->
            <h3>üìä HashMap vs. TreeMap - Der direkte Vergleich</h3>
            
            <table class="complexity-table">
                <tr>
                    <th>Aspekt</th>
                    <th>HashMap</th>
                    <th>TreeMap</th>
                </tr>
                <tr>
                    <td><strong>Sortierung</strong></td>
                    <td class="complexity-bad">Keine Reihenfolge</td>
                    <td class="complexity-good">Nach Schl√ºsseln sortiert</td>
                </tr>
                <tr>
                    <td><strong>Geschwindigkeit</strong></td>
                    <td class="complexity-good">O(1) - sehr schnell ‚ö°</td>
                    <td class="complexity-medium">O(log n) - langsamer</td>
                </tr>
                <tr>
                    <td><strong>null-Schl√ºssel</strong></td>
                    <td class="complexity-good">1x erlaubt</td>
                    <td class="complexity-bad">Nicht erlaubt</td>
                </tr>
                <tr>
                    <td><strong>Navigation</strong></td>
                    <td class="complexity-bad">Keine</td>
                    <td class="complexity-good">first(), last(), etc.</td>
                </tr>
                <tr>
                    <td><strong>Speicher</strong></td>
                    <td class="complexity-good">Weniger</td>
                    <td class="complexity-bad">Mehr</td>
                </tr>
                <tr>
                    <td><strong>Wann nutzen?</strong></td>
                    <td class="complexity-good">Schnellster Zugriff</td>
                    <td class="complexity-good">Sortierung wichtig</td>
                </tr>
            </table>

            <!-- ========== ENTSCHEIDUNGSHILFE ========== -->
            <h3>üéØ Welche Collection wann? - Entscheidungshilfe</h3>
            
            <div class="algorithm-comparison">
                <div class="algorithm-card">
                    <h4>üìã Brauche ich eine Liste?</h4>
                    <p><strong>‚Üí Duplikate erlaubt, Reihenfolge wichtig</strong></p>
                    <ul>
                        <li>Viel Lesen? ‚Üí <strong>ArrayList</strong></li>
                        <li>Viel Einf√ºgen/L√∂schen? ‚Üí <strong>LinkedList</strong></li>
                    </ul>
                </div>
                
                <div class="algorithm-card">
                    <h4>üè∑Ô∏è Brauche ich ein Set?</h4>
                    <p><strong>‚Üí Keine Duplikate, Eindeutigkeit wichtig</strong></p>
                    <ul>
                        <li>Nur eindeutig, schnell? ‚Üí <strong>HashSet</strong></li>
                        <li>Eindeutig UND sortiert? ‚Üí <strong>TreeSet</strong></li>
                    </ul>
                </div>
                
                <div class="algorithm-card">
                    <h4>üó∫Ô∏è Brauche ich eine Map?</h4>
                    <p><strong>‚Üí Zuordnung Schl√ºssel zu Wert</strong></p>
                    <ul>
                        <li>Nur schneller Zugriff? ‚Üí <strong>HashMap</strong></li>
                        <li>Sortierte Schl√ºssel? ‚Üí <strong>TreeMap</strong></li>
                    </ul>
                </div>
                
                <div class="algorithm-card">
                    <h4>‚ö° Brauche ich Stack/Queue?</h4>
                    <p><strong>‚Üí LIFO oder FIFO wichtig</strong></p>
                    <ul>
                        <li>Stack (LIFO)? ‚Üí <strong>LinkedList</strong> mit push/pop</li>
                        <li>Queue (FIFO)? ‚Üí <strong>LinkedList</strong> mit offer/poll</li>
                    </ul>
                </div>
            </div>

            <div class="warning-box">
                <h4>üí° Faustregel f√ºrs Abitur</h4>
                <ul>
                    <li><strong>ArrayList:</strong> "Ich brauche eine Liste mit schnellem Zugriff"</li>
                    <li><strong>LinkedList:</strong> "Ich f√ºge viel am Anfang/Ende ein"</li>
                    <li><strong>HashSet:</strong> "Keine Duplikate, schnell suchen"</li>
                    <li><strong>TreeSet:</strong> "Keine Duplikate, automatisch sortiert"</li>
                    <li><strong>HashMap:</strong> "W√∂rterbuch-Zuordnung, schnell"</li>
                    <li><strong>TreeMap:</strong> "W√∂rterbuch-Zuordnung, sortiert nach Keys"</li>
                </ul>
            </div>

            <!-- ========== COLLECTIONS UTILITIES ========== -->
            <h3>üõ†Ô∏è Collections-Hilfsmethoden</h3>
            
            <div class="code-block">
import java.util.*;

public class CollectionsUtils {
    public static void main(String[] args) {
        ArrayList<Integer> liste = new ArrayList<>();
        liste.add(5);
        liste.add(2);
        liste.add(8);
        liste.add(1);
        liste.add(9);
        
        // Sortieren
        Collections.sort(liste);
        System.out.println("Sortiert: " + liste);
        // [1, 2, 5, 8, 9]
        
        // Umkehren
        Collections.reverse(liste);
        System.out.println("Umgekehrt: " + liste);
        // [9, 8, 5, 2, 1]
        
        // Mischen
        Collections.shuffle(liste);
        System.out.println("Gemischt: " + liste);
        // [5, 1, 9, 2, 8] (zuf√§llig)
        
        // Maximum und Minimum
        int max = Collections.max(liste);
        int min = Collections.min(liste);
        System.out.println("Max: " + max + ", Min: " + min);
        
        // H√§ufigkeit
        liste.add(5);
        liste.add(5);
        int count = Collections.frequency(liste, 5);
        System.out.println("5 kommt " + count + "x vor");
        
        // Bin√§re Suche (NUR bei sortierten Listen!)
        Collections.sort(liste);
        int index = Collections.binarySearch(liste, 5);
        System.out.println("5 ist an Index: " + index);
    }
}
            </div>
        </section>

        <!-- 9. Bin√§rb√§ume (aus Original, gek√ºrzt) -->
        <section class="section">
            <h2>üå≥ 9. Bin√§rb√§ume</h2>
            
            <div class="definition-box">
                <strong>Bin√§rbaum:</strong> Hierarchische Struktur, jeder Knoten hat maximal zwei Kinder (links und rechts).
            </div>

            <div class="visual-demo">
                <div class="tree-visualization">
                    <div class="tree-level">
                        <div class="tree-node">8</div>
                    </div>
                    <div class="tree-level">
                        <div class="tree-node">3</div>
                        <div class="tree-node">10</div>
                    </div>
                    <div class="tree-level">
                        <div class="tree-node">1</div>
                        <div class="tree-node">6</div>
                        <div class="tree-node">14</div>
                    </div>
                </div>
            </div>

            <h3>üîÑ Durchlaufarten</h3>
            
            <ul>
                <li><strong>Preorder:</strong> Wurzel ‚Üí Links ‚Üí Rechts (8, 3, 1, 6, 10, 14)</li>
                <li><strong>Inorder:</strong> Links ‚Üí Wurzel ‚Üí Rechts (1, 3, 6, 8, 10, 14)</li>
                <li><strong>Postorder:</strong> Links ‚Üí Rechts ‚Üí Wurzel (1, 6, 3, 14, 10, 8)</li>
            </ul>
        </section>

        <!-- 10. Sortieralgorithmen -->
        <section class="section">
            <h2>üîÄ 10. Sortieralgorithmen</h2>
            
            <h3>ü´ß Bubblesort</h3>
            
            <div class="code-block">
public static void bubblesort(int[] array) {
    int n = array.length;
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (array[j] > array[j + 1]) {
                // Tauschen
                int temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }
}
            </div>

            <h3>‚ö° Quicksort</h3>
            
            <div class="code-block">
public static void quicksort(int[] array, int low, int high) {
    if (low < high) {
        int pi = partition(array, low, high);
        quicksort(array, low, pi - 1);
        quicksort(array, pi + 1, high);
    }
}

private static int partition(int[] array, int low, int high) {
    int pivot = array[high];
    int i = (low - 1);
    
    for (int j = low; j < high; j++) {
        if (array[j] < pivot) {
            i++;
            int temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
    }
    
    int temp = array[i + 1];
    array[i + 1] = array[high];
    array[high] = temp;
    
    return i + 1;
}
            </div>

            <h3>üìä Vergleich</h3>
            
            <table class="complexity-table">
                <tr>
                    <th>Algorithmus</th>
                    <th>Best</th>
                    <th>Average</th>
                    <th>Worst</th>
                </tr>
                <tr class="complexity-bad">
                    <td>Bubblesort</td>
                    <td>O(n)</td>
                    <td>O(n¬≤)</td>
                    <td>O(n¬≤)</td>
                </tr>
                <tr class="complexity-good">
                    <td>Quicksort</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>O(n¬≤)</td>
                </tr>
                <tr class="complexity-good">
                    <td>Mergesort</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                </tr>
            </table>
        </section>

        <!-- 11. Suchalgorithmen -->
        <section class="section">
            <h2>üîç 11. Suchalgorithmen</h2>
            
            <h3>üìç Lineare Suche</h3>
            
            <div class="code-block">
public static int lineareSuche(int[] array, int gesucht) {
    for (int i = 0; i < array.length; i++) {
        if (array[i] == gesucht) {
            return i;
        }
    }
    return -1;  // Nicht gefunden
}
            </div>

            <h3>üéØ Bin√§re Suche</h3>
            
            <div class="code-block">
public static int binaereSuche(int[] array, int gesucht) {
    int links = 0;
    int rechts = array.length - 1;
    
    while (links <= rechts) {
        int mitte = (links + rechts) / 2;
        
        if (array[mitte] == gesucht) {
            return mitte;
        } else if (array[mitte] < gesucht) {
            links = mitte + 1;
        } else {
            rechts = mitte - 1;
        }
    }
    return -1;
}
            </div>

            <table class="complexity-table">
                <tr>
                    <th>Algorithmus</th>
                    <th>Voraussetzung</th>
                    <th>Komplexit√§t</th>
                </tr>
                <tr class="complexity-medium">
                    <td>Lineare Suche</td>
                    <td>Keine</td>
                    <td>O(n)</td>
                </tr>
                <tr class="complexity-good">
                    <td>Bin√§re Suche</td>
                    <td>Sortiert!</td>
                    <td>O(log n)</td>
                </tr>
            </table>
        </section>

        <!-- 12. Rekursion -->
        <section class="section">
            <h2>üîÑ 12. Rekursion vs. Iteration</h2>
            
            <div class="comparison-grid">
                <div class="comparison-card">
                    <h4>Rekursiv</h4>
                    <div class="code-block">
public static int fakultaet(int n) {
    if (n <= 1) {
        return 1;
    }
    return n * fakultaet(n - 1);
}
                    </div>
                </div>
                <div class="comparison-card">
                    <h4>Iterativ</h4>
                    <div class="code-block">
public static int fakultaet(int n) {
    int ergebnis = 1;
    for (int i = 1; i <= n; i++) {
        ergebnis *= i;
    }
    return ergebnis;
}
                    </div>
                </div>
            </div>
        </section>

        <!-- INTERAKTIVE DEMO -->
        <section class="section">
            <h2>üéÆ 13. Interaktive Linked List Demo</h2>
            
            <div class="interactive-demo">
                <h3>üîó Verkettete Liste Simulator</h3>
                <div class="demo-controls">
                    <input type="text" id="linkedListInput" placeholder="Element eingeben...">
                    <button class="demo-button" onclick="linkedListAdd()">‚ûï Am Ende hinzuf√ºgen</button>
                    <button class="demo-button" onclick="linkedListAddFirst()">‚¨ÜÔ∏è Am Anfang hinzuf√ºgen</button>
                    <button class="demo-button" onclick="linkedListRemove()">‚ùå Erstes entfernen</button>
                    <button class="demo-button" onclick="linkedListClear()">üóëÔ∏è Alles l√∂schen</button>
                </div>
                
                <div id="linkedListDisplay" class="visual-demo">
                    <div class="linked-list-visual" id="linkedListNodes">
                        <div style="font-weight: bold; color: var(--primary-color);">Leer</div>
                    </div>
                </div>
                
                <div id="linkedListInfo" style="margin-top: 1rem; font-weight: bold; color: var(--primary-color);">
                    Gr√∂√üe: 0 Elemente
                </div>
            </div>
        </section>

        <!-- ZUSAMMENFASSUNG -->
        <section class="section">
            <h2>üìö 14. Zusammenfassung f√ºr's Abitur</h2>
            
            <div class="warning-box">
                <h4>üéØ Must-Know Konzepte</h4>
                <ul>
                    <li>‚úÖ <strong>Generics:</strong> <code>&lt;T&gt;</code> f√ºr flexible Typen</li>
                    <li>‚úÖ <strong>Static vs. Non-static:</strong> Wann welche innere Klasse?</li>
                    <li>‚úÖ <strong>Verkettete Listen:</strong> Aufbau, Operationen, Komplexit√§t</li>
                    <li>‚úÖ <strong>Collections:</strong> ArrayList, HashSet, HashMap - wann was?</li>
                    <li>‚úÖ <strong>Sortieren:</strong> Bubblesort vs. Quicksort</li>
                    <li>‚úÖ <strong>Suchen:</strong> Linear vs. Bin√§r</li>
                    <li>‚úÖ <strong>O-Notation:</strong> O(1), O(n), O(log n), O(n¬≤)</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>üí° Klausur-Tipps</h4>
                <ol>
                    <li>Bei Generics immer Typ-Parameter angeben: <code>Liste&lt;String&gt;</code></li>
                    <li>Static innere Klassen f√ºr unabh√§ngige Hilfsklassen (Auto, Node)</li>
                    <li>Linked Lists: Immer an <code>head</code> und <code>null</code> denken</li>
                    <li>Bei Sortieralgorithmen jeden Schritt aufschreiben</li>
                    <li>Bin√§re Suche nur bei sortierten Arrays!</li>
                </ol>
            </div>
        </section>

        <div class="navigation">
            <a href="index.html" class="nav-button">‚¨ÖÔ∏è Zur Startseite</a>
            <span>Algorithmen & Datenstrukturen - Vollst√§ndig</span>
            <a href="index.html" class="nav-button">Weitere Themen ‚û°Ô∏è</a>
        </div>
    </div>

    <script>
        // Linked List Demo
        let linkedList = [];

        function updateLinkedListDisplay() {
            const container = document.getElementById('linkedListNodes');
            container.innerHTML = '';
            
            if (linkedList.length === 0) {
                container.innerHTML = '<div style="font-weight: bold; color: var(--primary-color);">head ‚Üí null</div>';
            } else {
                // head
                const headLabel = document.createElement('div');
                headLabel.style.fontWeight = 'bold';
                headLabel.style.color = 'var(--primary-color)';
                headLabel.textContent = 'head ‚Üí';
                container.appendChild(headLabel);
                
                // Nodes
                linkedList.forEach((item, index) => {
                    const nodeBox = document.createElement('div');
                    nodeBox.className = 'node-box';
                    
                    const nodeData = document.createElement('div');
                    nodeData.className = 'node-data';
                    nodeData.textContent = item;
                    
                    const arrow = document.createElement('div');
                    arrow.textContent = '‚Üí';
                    
                    nodeBox.appendChild(nodeData);
                    nodeBox.appendChild(arrow);
                    container.appendChild(nodeBox);
                });
                
                // null
                const nullBox = document.createElement('div');
                nullBox.className = 'null-box';
                nullBox.textContent = 'null';
                container.appendChild(nullBox);
            }
            
            document.getElementById('linkedListInfo').textContent = 
                `Gr√∂√üe: ${linkedList.length} Element${linkedList.length !== 1 ? 'e' : ''}`;
        }

        function linkedListAdd() {
            const input = document.getElementById('linkedListInput');
            const value = input.value.trim();
            
            if (value) {
                linkedList.push(value);
                input.value = '';
                updateLinkedListDisplay();
            } else {
                alert('Bitte gib ein Element ein!');
            }
        }

        function linkedListAddFirst() {
            const input = document.getElementById('linkedListInput');
            const value = input.value.trim();
            
            if (value) {
                linkedList.unshift(value);
                input.value = '';
                updateLinkedListDisplay();
            } else {
                alert('Bitte gib ein Element ein!');
            }
        }

        function linkedListRemove() {
            if (linkedList.length > 0) {
                linkedList.shift();
                updateLinkedListDisplay();
            } else {
                alert('Liste ist bereits leer!');
            }
        }

        function linkedListClear() {
            linkedList = [];
            updateLinkedListDisplay();
        }

        // Initialisierung
        updateLinkedListDisplay();

        // Enter-Taste f√ºr Hinzuf√ºgen
        document.getElementById('linkedListInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                linkedListAdd();
            }
        });
    </script>
</body>
</html>


